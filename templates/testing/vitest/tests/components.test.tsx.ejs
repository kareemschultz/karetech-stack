import { describe, it, expect } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { Button } from '@/components/ui/button'
import { Loading, LoadingPage, LoadingButton } from '@/components/ui/loading'
import { ErrorBoundary } from '@/components/error-boundary'

describe('Button Component', () => {
  it('should render button with correct text', () => {
    render(<Button>Click me</Button>)

    expect(screen.getByRole('button', { name: /click me/i })).toBeInTheDocument()
  })

  it('should apply variant classes correctly', () => {
    render(<Button variant="secondary">Secondary Button</Button>)

    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-secondary')
  })

  it('should handle click events', async () => {
    const handleClick = vi.fn()
    const user = userEvent.setup()

    render(<Button onClick={handleClick}>Click me</Button>)

    await user.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('should be disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled Button</Button>)

    const button = screen.getByRole('button')
    expect(button).toBeDisabled()
  })

  it('should forward ref correctly', () => {
    const ref = vi.fn()
    render(<Button ref={ref}>Button with ref</Button>)

    expect(ref).toHaveBeenCalled()
  })
})

describe('Loading Components', () => {
  describe('Loading', () => {
    it('should render loading spinner', () => {
      render(<Loading />)

      const spinner = document.querySelector('.animate-spin')
      expect(spinner).toBeInTheDocument()
    })

    it('should render with text', () => {
      render(<Loading text="Loading data..." />)

      expect(screen.getByText('Loading data...')).toBeInTheDocument()
    })

    it('should apply size classes correctly', () => {
      render(<Loading size="lg" />)

      const spinner = document.querySelector('.h-12.w-12')
      expect(spinner).toBeInTheDocument()
    })
  })

  describe('LoadingPage', () => {
    it('should render full page loading', () => {
      render(<LoadingPage />)

      expect(screen.getByText('Loading...')).toBeInTheDocument()
      expect(document.querySelector('.min-h-screen')).toBeInTheDocument()
    })

    it('should render with custom text', () => {
      render(<LoadingPage text="Please wait..." />)

      expect(screen.getByText('Please wait...')).toBeInTheDocument()
    })
  })

  describe('LoadingButton', () => {
    it('should show loading state', () => {
      render(<LoadingButton isLoading>Save</LoadingButton>)

      const button = screen.getByRole('button')
      expect(button).toBeDisabled()
      expect(document.querySelector('.animate-spin')).toBeInTheDocument()
    })

    it('should not show loading when not loading', () => {
      render(<LoadingButton isLoading={false}>Save</LoadingButton>)

      const button = screen.getByRole('button')
      expect(button).not.toBeDisabled()
      expect(document.querySelector('.animate-spin')).not.toBeInTheDocument()
    })
  })
})

describe('ErrorBoundary', () => {
  const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
    if (shouldThrow) {
      throw new Error('Test error')
    }
    return <div>No error</div>
  }

  it('should render children when no error', () => {
    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    )

    expect(screen.getByText('No error')).toBeInTheDocument()
  })

  it('should render error UI when error occurs', () => {
    // Suppress error console logs for this test
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

    render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )

    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /refresh page/i })).toBeInTheDocument()

    consoleSpy.mockRestore()
  })

  it('should retry on button click', async () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
    const user = userEvent.setup()

    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )

    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()

    // Click retry button
    await user.click(screen.getByRole('button', { name: /try again/i }))

    // Re-render with working component
    rerender(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    )

    await waitFor(() => {
      expect(screen.getByText('No error')).toBeInTheDocument()
    })

    consoleSpy.mockRestore()
  })

  it('should use custom fallback component', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})

    const CustomFallback = ({ error, retry }: { error: Error; retry: () => void }) => (
      <div>
        <p>Custom error: {error.message}</p>
        <button onClick={retry}>Custom retry</button>
      </div>
    )

    render(
      <ErrorBoundary fallback={CustomFallback}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    )

    expect(screen.getByText('Custom error: Test error')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: /custom retry/i })).toBeInTheDocument()

    consoleSpy.mockRestore()
  })
})

// Test utilities
describe('Test Utilities', () => {
  it('should have proper test environment setup', () => {
    expect(vi).toBeDefined()
    expect(import.meta.env.MODE).toBe('test')
  })

  it('should mock localStorage correctly', () => {
    localStorage.setItem('test', 'value')
    expect(localStorage.setItem).toHaveBeenCalledWith('test', 'value')
  })

  it('should mock fetch correctly', async () => {
    const mockResponse = { data: 'test' }
    global.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    })

    const response = await fetch('/api/test')
    const data = await response.json()

    expect(data).toEqual(mockResponse)
    expect(global.fetch).toHaveBeenCalledWith('/api/test')
  })
})