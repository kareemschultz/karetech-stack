import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import {
  cn,
  getStoredValue,
  setStoredValue,
  removeStoredValue,
  formatDate,
  formatRelativeTime,
  debounce,
  throttle,
  AppError,
  handleError,
} from '@/lib/utils'

describe('utils', () => {
  describe('cn (className utility)', () => {
    it('should merge class names correctly', () => {
      expect(cn('class1', 'class2')).toBe('class1 class2')
    })

    it('should handle conditional classes', () => {
      expect(cn('base', true && 'conditional', false && 'hidden')).toBe('base conditional')
    })

    it('should merge tailwind classes with precedence', () => {
      expect(cn('bg-red-500', 'bg-blue-500')).toBe('bg-blue-500')
    })
  })

  describe('localStorage utilities', () => {
    beforeEach(() => {
      localStorage.clear()
      vi.clearAllMocks()
    })

    it('should store and retrieve values', () => {
      const testData = { name: 'test', value: 123 }
      setStoredValue('testKey', testData)

      expect(localStorage.setItem).toHaveBeenCalledWith(
        'testKey',
        JSON.stringify(testData)
      )

      // Mock the return value
      localStorage.getItem.mockReturnValue(JSON.stringify(testData))

      const retrieved = getStoredValue('testKey', null)
      expect(retrieved).toEqual(testData)
    })

    it('should return default value when key does not exist', () => {
      localStorage.getItem.mockReturnValue(null)

      const result = getStoredValue('nonexistent', 'default')
      expect(result).toBe('default')
    })

    it('should handle JSON parse errors gracefully', () => {
      localStorage.getItem.mockReturnValue('invalid json')

      const result = getStoredValue('corrupt', 'default')
      expect(result).toBe('default')
    })

    it('should remove stored values', () => {
      removeStoredValue('testKey')
      expect(localStorage.removeItem).toHaveBeenCalledWith('testKey')
    })
  })

  describe('date formatting', () => {
    it('should format dates correctly', () => {
      const date = new Date('2024-01-15T12:00:00Z')
      const formatted = formatDate(date)

      expect(formatted).toMatch(/January 15, 2024/)
    })

    it('should format dates with custom options', () => {
      const date = new Date('2024-01-15T12:00:00Z')
      const formatted = formatDate(date, { month: 'short', day: 'numeric' })

      expect(formatted).toMatch(/Jan 15/)
    })

    it('should handle string dates', () => {
      const formatted = formatDate('2024-01-15', { year: 'numeric' })
      expect(formatted).toMatch(/2024/)
    })
  })

  describe('relative time formatting', () => {
    it('should show "just now" for recent times', () => {
      const now = new Date()
      const result = formatRelativeTime(now)
      expect(result).toBe('just now')
    })

    it('should show minutes for recent times', () => {
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000)
      const result = formatRelativeTime(fiveMinutesAgo)
      expect(result).toBe('5 minutes ago')
    })

    it('should show hours for older times', () => {
      const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000)
      const result = formatRelativeTime(twoHoursAgo)
      expect(result).toBe('2 hours ago')
    })
  })

  describe('debounce', () => {
    it('should debounce function calls', async () => {
      const fn = vi.fn()
      const debouncedFn = debounce(fn, 100)

      debouncedFn()
      debouncedFn()
      debouncedFn()

      expect(fn).not.toHaveBeenCalled()

      await new Promise(resolve => setTimeout(resolve, 150))
      expect(fn).toHaveBeenCalledTimes(1)
    })
  })

  describe('throttle', () => {
    it('should throttle function calls', async () => {
      const fn = vi.fn()
      const throttledFn = throttle(fn, 100)

      throttledFn()
      throttledFn()
      throttledFn()

      expect(fn).toHaveBeenCalledTimes(1)

      await new Promise(resolve => setTimeout(resolve, 150))
      throttledFn()

      expect(fn).toHaveBeenCalledTimes(2)
    })
  })

  describe('error handling', () => {
    it('should create AppError with message', () => {
      const error = new AppError('Test error', 'TEST_CODE', 500)

      expect(error.message).toBe('Test error')
      expect(error.code).toBe('TEST_CODE')
      expect(error.statusCode).toBe(500)
      expect(error.name).toBe('AppError')
    })

    it('should handle AppError instances', () => {
      const originalError = new AppError('Original error')
      const handled = handleError(originalError)

      expect(handled).toBe(originalError)
    })

    it('should convert Error to AppError', () => {
      const originalError = new Error('Standard error')
      const handled = handleError(originalError)

      expect(handled).toBeInstanceOf(AppError)
      expect(handled.message).toBe('Standard error')
    })

    it('should handle unknown errors', () => {
      const handled = handleError('string error')

      expect(handled).toBeInstanceOf(AppError)
      expect(handled.message).toBe('An unknown error occurred')
    })
  })
})