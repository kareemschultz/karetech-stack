/**
 * Testing framework template generation system
 * Constitutional compliance: Comprehensive testing with E2E and unit testing
 */

import { promises as fs } from 'fs';
import { join } from 'path';
import { existsSync, mkdirSync } from 'fs';
import { ProjectConfig } from '../types';
// copyTemplateDirectory, processTemplate imports removed - were unused

/**
 * Playwright configuration generator
 */
export async function generatePlaywrightConfig(projectDir: string, config: ProjectConfig): Promise<void> {
  const playwrightConfig = `import { defineConfig, devices } from '@playwright/test';

/**
 * Playwright E2E Testing Configuration
 * Generated by create-karetech-stack
 */
export default defineConfig({
  testDir: './tests/e2e',

  /* Run tests in files in parallel */
  fullyParallel: true,

  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,

  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,

  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,

  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results/results.json' }],
    process.env.CI ? ['github'] : ['list']
  ],

  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like \`await page.goto('/')\`. */
    baseURL: 'http://localhost:${config.projectName === 'minimal' ? '3000' : '5173'}',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',

    /* Take screenshot on failure */
    screenshot: 'only-on-failure',

    /* Capture video on failure */
    video: 'retain-on-failure',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'bun run dev',
    url: 'http://localhost:${config.projectName === 'minimal' ? '3000' : '5173'}',
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },
});
`;

  await fs.writeFile(join(projectDir, 'playwright.config.ts'), playwrightConfig, 'utf-8');
}

/**
 * Vitest configuration generator
 */
export async function generateVitestConfig(projectDir: string, _config: ProjectConfig): Promise<void> {
  const vitestConfig = `import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react-swc';
import path from 'path';

/**
 * Vitest Unit Testing Configuration
 * Generated by create-karetech-stack
 */
export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/setup.ts',
        '**/*.d.ts',
        '**/*.config.*',
        'dist/',
        'build/',
        '.next/',
        'coverage/',
      ],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/components': path.resolve(__dirname, './src/components'),
      '@/lib': path.resolve(__dirname, './src/lib'),
      '@/hooks': path.resolve(__dirname, './src/hooks'),
    },
  },
});
`;

  await fs.writeFile(join(projectDir, 'vitest.config.ts'), vitestConfig, 'utf-8');
}

/**
 * Puppeteer test runner configuration
 */
export async function generatePuppeteerConfig(projectDir: string, config: ProjectConfig): Promise<void> {
  const puppeteerScript = `#!/usr/bin/env node

/**
 * Puppeteer E2E Test Runner
 * Generated by create-karetech-stack
 */

import puppeteer from 'puppeteer';
import { resolve } from 'path';
import { existsSync } from 'fs';

const BASE_URL = 'http://localhost:${config.projectName === 'minimal' ? '3000' : '5173'}';
const TIMEOUT = 30000;

async function runE2ETests() {
  console.log('üé≠ Starting Puppeteer E2E tests...');

  const browser = await puppeteer.launch({
    headless: process.env.CI ? true : false,
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });

  try {
    const page = await browser.newPage();
    await page.setViewport({ width: 1280, height: 720 });

    // Basic navigation test
    console.log('üìÑ Testing homepage navigation...');
    await page.goto(BASE_URL, { waitUntil: 'networkidle0', timeout: TIMEOUT });

    const title = await page.title();
    console.log(\`‚úÖ Page title: \${title}\`);

    // Screenshot for visual verification
    await page.screenshot({
      path: 'tests/screenshots/homepage.png',
      fullPage: true
    });

    console.log('‚úÖ Basic navigation test passed');

    // Add more tests here based on your app structure
    ${config.auth.length > 0 ? `
    // Authentication test
    if (await page.$('button[data-testid="login"]')) {
      console.log('üîê Testing authentication flow...');
      // Add auth-specific tests
      console.log('‚úÖ Authentication tests passed');
    }` : ''}

    console.log('üéâ All Puppeteer E2E tests passed!');

  } catch (error) {
    console.error('‚ùå E2E tests failed:', error);
    process.exit(1);
  } finally {
    await browser.close();
  }
}

// Run if called directly
if (import.meta.url === \`file://\${process.argv[1]}\`) {
  runE2ETests().catch(console.error);
}

export { runE2ETests };
`;

  // Create scripts directory if it doesn't exist
  const scriptsDir = join(projectDir, 'scripts');
  if (!existsSync(scriptsDir)) {
    mkdirSync(scriptsDir, { recursive: true });
  }

  await fs.writeFile(join(scriptsDir, 'e2e-puppeteer.js'), puppeteerScript, 'utf-8');
}

/**
 * Generate test setup file for React Testing Library
 */
export async function generateTestSetup(projectDir: string, config: ProjectConfig): Promise<void> {
  const setupContent = `/**
 * Test setup configuration
 * Generated by create-karetech-stack
 */

import '@testing-library/jest-dom';
import { beforeEach, afterEach, vi } from 'vitest';
import { cleanup } from '@testing-library/react';

// Global test setup
beforeEach(() => {
  // Reset any mocks
  vi.clearAllMocks();
});

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  unobserve: vi.fn(),
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn(() => ({
  disconnect: vi.fn(),
  observe: vi.fn(),
  unobserve: vi.fn(),
}));

// Mock matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(), // deprecated
    removeListener: vi.fn(), // deprecated
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock scrollTo
window.scrollTo = vi.fn();

${config.pwa ? `
// Mock service worker registration
Object.defineProperty(navigator, 'serviceWorker', {
  value: {
    register: vi.fn(),
    ready: Promise.resolve({
      unregister: vi.fn(),
    }),
  },
  writable: true,
});
` : ''}

${config.auth.length > 0 ? `
// Mock authentication
vi.mock('@/lib/auth', () => ({
  signIn: vi.fn(),
  signOut: vi.fn(),
  getSession: vi.fn().mockResolvedValue(null),
}));
` : ''}
`;

  const testDir = join(projectDir, 'src', 'test');
  if (!existsSync(testDir)) {
    mkdirSync(testDir, { recursive: true });
  }

  await fs.writeFile(join(testDir, 'setup.ts'), setupContent, 'utf-8');
}

/**
 * Generate example test files
 */
export async function generateExampleTests(projectDir: string, config: ProjectConfig): Promise<void> {
  if (!config.exampleTests) return;

  const testsDir = join(projectDir, 'tests');
  if (!existsSync(testsDir)) {
    mkdirSync(testsDir, { recursive: true });
  }

  // E2E test example
  if (config.testing.includes('playwright')) {
    const e2eDir = join(testsDir, 'e2e');
    if (!existsSync(e2eDir)) {
      mkdirSync(e2eDir, { recursive: true });
    }

    const playwrightTest = `import { test, expect } from '@playwright/test';

/**
 * Example E2E tests
 * Generated by create-karetech-stack
 */

test.describe('Homepage', () => {
  test('should load successfully', async ({ page }) => {
    await page.goto('/');

    await expect(page).toHaveTitle(/${config.projectName}/i);
    await expect(page.getByRole('main')).toBeVisible();
  });

  test('should have working navigation', async ({ page }) => {
    await page.goto('/');

    // Test navigation elements are present
    const nav = page.getByRole('navigation');
    await expect(nav).toBeVisible();
  });

  ${config.auth.length > 0 ? `
  test('should handle authentication flow', async ({ page }) => {
    await page.goto('/');

    // Test login button is present
    const loginButton = page.getByTestId('login-button');
    if (await loginButton.isVisible()) {
      await expect(loginButton).toBeVisible();
    }
  });
  ` : ''}
});

test.describe('Responsiveness', () => {
  test('should work on mobile viewport', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');

    await expect(page.getByRole('main')).toBeVisible();
  });

  test('should work on tablet viewport', async ({ page }) => {
    await page.setViewportSize({ width: 768, height: 1024 });
    await page.goto('/');

    await expect(page.getByRole('main')).toBeVisible();
  });

  test('should work on desktop viewport', async ({ page }) => {
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.goto('/');

    await expect(page.getByRole('main')).toBeVisible();
  });
});
`;

    await fs.writeFile(join(e2eDir, 'example.spec.ts'), playwrightTest, 'utf-8');
  }

  // Unit test examples
  if (config.unitTesting) {
    const unitTestsDir = join(projectDir, 'src', 'components', '__tests__');
    if (!existsSync(unitTestsDir)) {
      mkdirSync(unitTestsDir, { recursive: true });
    }

    const unitTest = `import { render, screen } from '@testing-library/react';
import { userEvent } from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';

/**
 * Example component tests
 * Generated by create-karetech-stack
 */

// Mock component for testing
const TestButton = ({ onClick, children }: { onClick: () => void; children: React.ReactNode }) => (
  <button onClick={onClick} data-testid="test-button">
    {children}
  </button>
);

describe('TestButton', () => {
  it('renders correctly', () => {
    const mockClick = vi.fn();
    render(<TestButton onClick={mockClick}>Click me</TestButton>);

    expect(screen.getByTestId('test-button')).toBeInTheDocument();
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('handles click events', async () => {
    const user = userEvent.setup();
    const mockClick = vi.fn();

    render(<TestButton onClick={mockClick}>Click me</TestButton>);

    await user.click(screen.getByTestId('test-button'));

    expect(mockClick).toHaveBeenCalledOnce();
  });

  it('is accessible', () => {
    const mockClick = vi.fn();
    render(<TestButton onClick={mockClick}>Click me</TestButton>);

    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
    expect(button).toBeEnabled();
  });
});

// Example hook test
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
};

describe('useCounter hook', () => {
  it('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());

    expect(result.current.count).toBe(0);
  });

  it('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(5));

    expect(result.current.count).toBe(5);
  });

  it('increments count', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  it('decrements count', () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(4);
  });

  it('resets count', () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.increment();
      result.current.increment();
    });

    expect(result.current.count).toBe(7);

    act(() => {
      result.current.reset();
    });

    expect(result.current.count).toBe(5);
  });
});
`;

    await fs.writeFile(join(unitTestsDir, 'example.test.tsx'), unitTest, 'utf-8');
  }
}

/**
 * Generate GitHub Actions workflow for testing
 */
export async function generateTestingWorkflow(projectDir: string, config: ProjectConfig): Promise<void> {
  if (config.cicd !== 'github-actions') return;

  const workflowDir = join(projectDir, '.github', 'workflows');
  if (!existsSync(workflowDir)) {
    mkdirSync(workflowDir, { recursive: true });
  }

  const workflow = `name: Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Type check
        run: bun run typecheck

      - name: Lint
        run: bun run lint

      ${config.unitTesting || config.testing.includes('vitest') ? `
      - name: Run unit tests
        run: bun run test

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/coverage-final.json
          flags: unit` : ''}

      ${config.testing.includes('playwright') ? `
      - name: Install Playwright browsers
        run: bunx playwright install --with-deps

      - name: Run Playwright tests
        run: bun run test:e2e

      - name: Upload Playwright report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30` : ''}

      ${config.testing.includes('puppeteer') ? `
      - name: Run Puppeteer tests
        run: bun run test:e2e:puppeteer

      - name: Upload screenshots
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: puppeteer-screenshots
          path: tests/screenshots/
          retention-days: 7` : ''}
`;

  await fs.writeFile(join(workflowDir, 'test.yml'), workflow, 'utf-8');
}

/**
 * Main testing framework generator
 */
export async function generateTestingFramework(projectDir: string, config: ProjectConfig): Promise<void> {
  // Context creation removed - was unused

  // Generate configurations for selected testing frameworks
  if (config.testing.includes('playwright')) {
    await generatePlaywrightConfig(projectDir, config);
  }

  if (config.testing.includes('vitest') || config.unitTesting) {
    await generateVitestConfig(projectDir, config);
  }

  if (config.testing.includes('puppeteer')) {
    await generatePuppeteerConfig(projectDir, config);
  }

  // Generate test setup
  if (config.unitTesting) {
    await generateTestSetup(projectDir, config);
  }

  // Generate example tests
  if (config.exampleTests) {
    await generateExampleTests(projectDir, config);
  }

  // Generate GitHub Actions workflow
  if (config.cicd === 'github-actions') {
    await generateTestingWorkflow(projectDir, config);
  }

  console.log('‚úÖ Testing framework configuration generated');
}

/**
 * Validate testing configuration
 */
export function validateTestingConfig(config: ProjectConfig): string[] {
  const errors: string[] = [];

  // Check for conflicting configurations
  if (config.testing.includes('playwright') && config.testing.includes('puppeteer')) {
    console.warn('‚ö†Ô∏è  Both Playwright and Puppeteer selected - this is redundant but supported');
  }

  // Check for missing testing setup
  if (config.testing.length === 0 && !config.unitTesting) {
    console.warn('‚ö†Ô∏è  No testing frameworks selected - consider adding at least unit testing');
  }

  return errors;
}