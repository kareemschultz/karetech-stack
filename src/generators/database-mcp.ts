/**
 * Database MCP Server Generator
 * Task 1.5: Pre-configure Database MCP Servers
 *
 * Generates database MCP server configurations and templates based on project database choice.
 * Handles PostgreSQL, SQLite, and Turso with auto-configuration.
 *
 * Constitutional compliance: 100% TypeScript, no any types
 */

import { promises as fs } from 'fs';
import { join } from 'path';
import { existsSync, mkdirSync } from 'fs';
import { ProjectConfig, DatabaseType } from '../types';
import {
  DATABASE_MCP_REGISTRY,
  DatabaseMcpConfig,
  getDatabaseMcpConfig,
  generateMcpServerConfig,
  generateEnvTemplate,
  generateMcpSetupDocs,
  validateDatabaseMcpRequirements,
  hasMcpSupport,
  getMcpServerName
} from '../mcp/database-integration';

/**
 * MCP settings configuration structure
 */
interface McpSettingsConfig {
  command: string;
  args: string[];
  env?: Record<string, string>;
}

/**
 * Generate database MCP configuration for the project
 */
export async function generateDatabaseMcpConfig(
  projectDir: string,
  config: ProjectConfig
): Promise<void> {
  if (config.database === 'none') {
    console.log('â­ï¸  Skipping database MCP configuration (no database selected)');
    return;
  }

  const mcpConfig = getDatabaseMcpConfig(config.database);
  if (!mcpConfig) {
    console.log('â­ï¸  No MCP configuration available for database type:', config.database);
    return;
  }

  console.log(`ðŸ—„ï¸  Configuring ${mcpConfig.displayName}...`);

  // Create MCP config directory
  const mcpDir = join(projectDir, '.mcp');
  if (!existsSync(mcpDir)) {
    mkdirSync(mcpDir, { recursive: true });
  }

  // Generate database-specific config file
  await generateDatabaseConfigFile(mcpDir, config, mcpConfig);

  // Generate environment template
  await generateDatabaseEnvTemplate(projectDir, config, mcpConfig);

  // Generate setup documentation
  await generateDatabaseMcpDocumentation(mcpDir, config, mcpConfig);

  // Validate configuration
  const validation = validateDatabaseMcpRequirements(config.database, config);
  if (validation.warnings.length > 0) {
    console.log('âš ï¸  Database MCP configuration warnings:');
    validation.warnings.forEach(w => console.log(`   - ${w}`));
  }

  console.log(`âœ… ${mcpConfig.displayName} configuration generated`);
}

/**
 * Generate database-specific MCP config file
 */
async function generateDatabaseConfigFile(
  mcpDir: string,
  config: ProjectConfig,
  mcpConfig: DatabaseMcpConfig
): Promise<void> {
  const configContent = {
    $schema: 'https://json.schemastore.org/mcp-config.json',
    name: mcpConfig.serverName,
    displayName: mcpConfig.displayName,
    description: mcpConfig.description,
    databaseType: mcpConfig.databaseType,
    package: mcpConfig.package.package,
    version: mcpConfig.package.version || 'latest',
    official: mcpConfig.package.official,
    readOnly: mcpConfig.readOnly,
    configuration: generateMcpServerConfig(config.database, config),
    capabilities: mcpConfig.capabilities,
    securityNotes: mcpConfig.securityNotes,
    environment: {
      required: mcpConfig.env.required,
      optional: mcpConfig.env.optional,
      defaults: mcpConfig.env.defaults
    }
  };

  await fs.writeFile(
    join(mcpDir, `${mcpConfig.serverName}-config.json`),
    JSON.stringify(configContent, null, 2),
    'utf-8'
  );
}

/**
 * Generate environment variable template for database
 */
async function generateDatabaseEnvTemplate(
  projectDir: string,
  config: ProjectConfig,
  mcpConfig: DatabaseMcpConfig
): Promise<void> {
  const envContent = generateEnvTemplate(config.database, config);

  // Append to .env.example if it exists, otherwise create a new .env.mcp.example
  const envExamplePath = join(projectDir, '.env.example');
  const envMcpPath = join(projectDir, '.env.mcp.example');

  if (existsSync(envExamplePath)) {
    // Append to existing .env.example
    const existingContent = await fs.readFile(envExamplePath, 'utf-8');
    if (!existingContent.includes('# Database MCP Configuration')) {
      const newContent = existingContent + '\n\n# Database MCP Configuration\n' + envContent;
      await fs.writeFile(envExamplePath, newContent, 'utf-8');
    }
  } else {
    // Create .env.mcp.example
    const header = `# ${config.projectName} - Database MCP Configuration
# Copy this to .env.local and update with your credentials
# Generated by create-karetech-stack

`;
    await fs.writeFile(envMcpPath, header + envContent, 'utf-8');
  }
}

/**
 * Generate database MCP setup documentation
 */
async function generateDatabaseMcpDocumentation(
  mcpDir: string,
  config: ProjectConfig,
  mcpConfig: DatabaseMcpConfig
): Promise<void> {
  const docs = generateMcpSetupDocs(config.database, config);

  const fullDocs = `# Database MCP Configuration for ${config.projectName}

> Generated by create-karetech-stack
> Database: ${config.database}

${docs}

## Quick Start

1. **Install the MCP server** (automatically included in project):
   \`\`\`bash
   npx ${mcpConfig.package.package}
   \`\`\`

2. **Configure environment variables**:
   \`\`\`bash
   cp .env.mcp.example .env.local
   # Edit .env.local with your database credentials
   \`\`\`

3. **Verify configuration**:
   - Claude Code will automatically detect the MCP configuration
   - Use the database tools to interact with your database

## Claude Code Integration

This database MCP server is configured in \`.claude/settings.json\` under \`mcpServers\`.

Example Claude Code usage:
- "Show me the database schema"
- "What tables exist in the database?"
- "Run a query to get all users"
${mcpConfig.readOnly ? '\nNote: This server is read-only and cannot modify data.' : ''}

## Troubleshooting

### Connection Issues

1. **Check environment variables**: Ensure all required variables are set in \`.env.local\`
2. **Verify database access**: Test connection manually before using MCP
3. **Check firewall rules**: Ensure the database port is accessible

### Permission Issues

${config.database === 'postgresql' ? `
- Ensure the PostgreSQL user has SELECT permissions on the required tables
- For schema inspection, USAGE permission on schemas is required
` : config.database === 'turso' ? `
- Verify your Turso auth token is valid and not expired
- Check if the database exists in your Turso dashboard
` : `
- Ensure the SQLite file has read permissions
- Check file path is correct and accessible
`}

---
*Documentation generated by create-karetech-stack*
`;

  await fs.writeFile(
    join(mcpDir, 'DATABASE_MCP.md'),
    fullDocs,
    'utf-8'
  );
}

/**
 * Generate MCP server entries for Claude Code settings.json
 * This returns the configuration to be merged into the main settings
 */
export function getDatabaseMcpSettingsEntry(
  config: ProjectConfig
): Record<string, McpSettingsConfig> | null {
  if (!hasMcpSupport(config.database)) {
    return null;
  }

  const dbMcpConfig = getDatabaseMcpConfig(config.database);
  if (!dbMcpConfig) {
    return null;
  }

  const serverName = getMcpServerName(config.database);
  if (!serverName) {
    return null;
  }

  const serverConfig = generateMcpServerConfig(config.database, config);
  if (!serverConfig) {
    return null;
  }

  // Convert the generic config to the expected MCP settings format
  const settingsEntry: McpSettingsConfig = {
    command: serverConfig.command as string,
    args: serverConfig.args as string[]
  };

  // Add env if present
  if (serverConfig.env) {
    settingsEntry.env = serverConfig.env as Record<string, string>;
  }

  return {
    [serverName]: settingsEntry
  };
}

/**
 * Generate all database MCP templates
 * Creates EJS templates for each supported database type
 */
export async function generateDatabaseMcpTemplates(
  templatesDir: string
): Promise<void> {
  const mcpTemplatesDir = join(templatesDir, 'mcp', 'database-configs');

  if (!existsSync(mcpTemplatesDir)) {
    mkdirSync(mcpTemplatesDir, { recursive: true });
  }

  // Generate templates for each database type
  for (const [dbType, mcpConfig] of Object.entries(DATABASE_MCP_REGISTRY)) {
    await generateDatabaseTemplate(mcpTemplatesDir, dbType as DatabaseType, mcpConfig);
  }

  // Generate the main database MCP index template
  await generateDatabaseMcpIndexTemplate(mcpTemplatesDir);

  console.log('âœ… Database MCP templates generated');
}

/**
 * Generate template for a specific database type
 */
async function generateDatabaseTemplate(
  templatesDir: string,
  dbType: DatabaseType,
  mcpConfig: DatabaseMcpConfig
): Promise<void> {
  const template = `{
  "$schema": "https://json.schemastore.org/mcp-config.json",
  "name": "${mcpConfig.serverName}",
  "displayName": "${mcpConfig.displayName}",
  "description": "${mcpConfig.description}",
  "databaseType": "${dbType}",
  "package": {
    "name": "${mcpConfig.package.package}",
    "version": "${mcpConfig.package.version || 'latest'}",
    "official": ${mcpConfig.package.official}
  },
  "configuration": {
    "command": "${mcpConfig.command}",
    "args": ${JSON.stringify(mcpConfig.args)},
    <% if (database === '${dbType}') { %>
    <% if ('${dbType}' === 'postgresql') { %>
    "env": {
      "DATABASE_URL": "postgresql://postgres:postgres@localhost:5432/<%= projectName %>"
    }
    <% } else if ('${dbType}' === 'turso') { %>
    "env": {
      "TURSO_DATABASE_URL": "\${TURSO_DATABASE_URL}",
      "TURSO_AUTH_TOKEN": "\${TURSO_AUTH_TOKEN}"
    }
    <% } %>
    <% } %>
  },
  "capabilities": ${JSON.stringify(mcpConfig.capabilities, null, 4)},
  "readOnly": ${mcpConfig.readOnly}
}
`;

  await fs.writeFile(
    join(templatesDir, `${mcpConfig.serverName}-config.json.ejs`),
    template,
    'utf-8'
  );
}

/**
 * Generate the index template that switches based on database type
 */
async function generateDatabaseMcpIndexTemplate(
  templatesDir: string
): Promise<void> {
  const indexTemplate = `<%# Database MCP Configuration Index Template %>
<%# This template generates the appropriate database MCP config based on project settings %>

<% if (database === 'postgresql') { %>
<%- include('./postgres-config.json.ejs') %>
<% } else if (database === 'sqlite') { %>
<%- include('./sqlite-config.json.ejs') %>
<% } else if (database === 'turso') { %>
<%- include('./turso-config.json.ejs') %>
<% } %>
`;

  await fs.writeFile(
    join(templatesDir, 'index.ejs'),
    indexTemplate,
    'utf-8'
  );
}

/**
 * Check if project should have database MCP configured
 */
export function shouldConfigureDatabaseMcp(config: ProjectConfig): boolean {
  // Only configure if database is not none and PBS level supports MCP
  return config.database !== 'none' &&
         config.pbsLevel !== 'none' &&
         (config.pbsLevel === 'full' || config.mcpServers.length > 0);
}

/**
 * Get recommendations for database MCP configuration
 */
export function getDatabaseMcpRecommendations(
  config: ProjectConfig
): string[] {
  const recommendations: string[] = [];

  if (config.database === 'none') {
    return recommendations;
  }

  const serverName = getMcpServerName(config.database);

  // Check if database MCP should be added
  if (serverName && !config.mcpServers.includes(serverName as 'postgres')) {
    recommendations.push(
      `Consider adding '${serverName}' to mcpServers for AI-assisted database operations`
    );
  }

  // Database-specific recommendations
  switch (config.database) {
    case 'postgresql':
      recommendations.push(
        'PostgreSQL MCP server provides read-only access - safe for production use'
      );
      break;
    case 'turso':
      recommendations.push(
        'Ensure TURSO_AUTH_TOKEN is kept secure and rotated regularly'
      );
      break;
    case 'sqlite':
      recommendations.push(
        'SQLite MCP server has write access - use caution in production'
      );
      break;
  }

  return recommendations;
}

/**
 * Export functions for use by other generators
 */
export {
  DATABASE_MCP_REGISTRY,
  getDatabaseMcpConfig,
  generateMcpServerConfig,
  generateEnvTemplate,
  validateDatabaseMcpRequirements
};
