/**
 * DevOps and deployment template generation system
 * Constitutional compliance: Production-ready Docker and CI/CD infrastructure
 */

import { promises as fs } from 'fs';
import { join, resolve } from 'path';
import { existsSync, mkdirSync } from 'fs';
import { ProjectConfig, TemplateContext } from '../types';

/**
 * Generate Dockerfile for production deployment
 */
export async function generateDockerfile(projectDir: string, config: ProjectConfig): Promise<void> {
  if (!config.docker) return;

  const dockerfile = `# Production Dockerfile
# Generated by create-karetech-stack
FROM oven/bun:1.1.38-alpine AS base

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apk add --no-cache \\
    curl \\
    dumb-init \\
    ${config.database === 'postgresql' ? 'postgresql-client \\' : ''}
    && rm -rf /var/cache/apk/*

# Copy package files
COPY package.json bun.lockb* ./

# Install dependencies
FROM base AS deps
RUN bun install --frozen-lockfile --production=false

# Build stage
FROM base AS build
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build the application
RUN bun run build

# Production stage
FROM base AS production

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nextjs -u 1001

# Copy built application
COPY --from=build --chown=nextjs:nodejs /app/dist ./dist
COPY --from=build --chown=nextjs:nodejs /app/package.json ./
COPY --from=deps --chown=nextjs:nodejs /app/node_modules ./node_modules

# Create necessary directories
RUN mkdir -p /app/logs && chown nextjs:nodejs /app/logs

# Switch to non-root user
USER nextjs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \\
    CMD curl -f http://localhost:3000/health || exit 1

# Start application with dumb-init
ENTRYPOINT ["dumb-init", "--"]
CMD ["bun", "run", "start"]
`;

  await fs.writeFile(join(projectDir, 'Dockerfile'), dockerfile, 'utf-8');
}

/**
 * Generate Docker Compose for development
 */
export async function generateDockerCompose(projectDir: string, config: ProjectConfig): Promise<void> {
  if (!config.docker) return;

  const services: Record<string, any> = {
    app: {
      build: {
        context: '.',
        dockerfile: 'Dockerfile',
        target: 'base'
      },
      ports: ['3000:3000'],
      volumes: [
        '.:/app',
        'node_modules:/app/node_modules'
      ],
      environment: {
        NODE_ENV: 'development'
      },
      command: 'bun run dev',
      depends_on: []
    }
  };

  // Add database service if needed
  if (config.database === 'postgresql') {
    services.postgres = {
      image: 'postgres:16-alpine',
      ports: ['5432:5432'],
      environment: {
        POSTGRES_DB: config.projectName,
        POSTGRES_USER: 'postgres',
        POSTGRES_PASSWORD: 'postgres'
      },
      volumes: [
        'postgres_data:/var/lib/postgresql/data',
        './scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql'
      ]
    };
    services.app.depends_on.push('postgres');
    services.app.environment.DATABASE_URL = 'postgresql://postgres:postgres@postgres:5432/' + config.projectName;
  }

  // Add Redis if needed for caching/sessions
  if (config.auth.length > 0 || config.featureFlags) {
    services.redis = {
      image: 'redis:7-alpine',
      ports: ['6379:6379'],
      command: 'redis-server --appendonly yes',
      volumes: ['redis_data:/data']
    };
    services.app.depends_on.push('redis');
    services.app.environment.REDIS_URL = 'redis://redis:6379';
  }

  const dockerCompose = {
    version: '3.8',
    services,
    volumes: {
      node_modules: {},
      ...(config.database === 'postgresql' ? { postgres_data: {} } : {}),
      ...(config.auth.length > 0 || config.featureFlags ? { redis_data: {} } : {})
    },
    networks: {
      default: {
        name: config.projectName + '_network'
      }
    }
  };

  await fs.writeFile(join(projectDir, 'docker-compose.yml'), `# Docker Compose Development Setup
# Generated by create-karetech-stack

version: '${dockerCompose.version}'

services:
${Object.entries(dockerCompose.services).map(([name, service]) =>
  `  ${name}:\n${Object.entries(service).map(([key, value]) => {
    if (key === 'environment' && value && typeof value === 'object') {
      return `    ${key}:\n${Object.entries(value as Record<string, any>).map(([envKey, envValue]) => `      ${envKey}: ${envValue}`).join('\n')}`;
    } else if (value && typeof value === 'object' && !Array.isArray(value)) {
      return `    ${key}:\n${Object.entries(value as Record<string, any>).map(([subKey, subValue]) => {
        if (subValue && typeof subValue === 'object' && !Array.isArray(subValue)) {
          return `      ${subKey}:\n${Object.entries(subValue as Record<string, any>).map(([subSubKey, subSubValue]) => `        ${subSubKey}: ${subSubValue}`).join('\n')}`;
        } else if (Array.isArray(subValue)) {
          return `      ${subKey}:\n${subValue.map(item => `        - ${item}`).join('\n')}`;
        } else {
          return `      ${subKey}: ${subValue}`;
        }
      }).join('\n')}`;
    } else if (Array.isArray(value)) {
      return `    ${key}:\n${value.map(item => `      - ${item}`).join('\n')}`;
    } else {
      return `    ${key}: ${value}`;
    }
  }).join('\n')}`
).join('\n\n')}

volumes:
${Object.keys(dockerCompose.volumes).map(vol => `  ${vol}:`).join('\n')}

networks:
  default:
    name: ${dockerCompose.networks.default.name}
`, 'utf-8');
}

/**
 * Generate GitHub Actions CI/CD workflow
 */
export async function generateGitHubActions(projectDir: string, config: ProjectConfig): Promise<void> {
  if (config.cicd !== 'github-actions') return;

  const workflowDir = join(projectDir, '.github', 'workflows');
  if (!existsSync(workflowDir)) {
    mkdirSync(workflowDir, { recursive: true });
  }

  const ciWorkflow = `name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_ENV: production
  ${config.deployTarget === 'vercel' ? 'VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}' : ''}
  ${config.deployTarget === 'vercel' ? 'VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}' : ''}

jobs:
  test:
    runs-on: ubuntu-latest

    ${config.database === 'postgresql' ? `
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432` : ''}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.bun/install/cache
          key: \${{ runner.os }}-bun-\${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            \${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Type check
        run: bun run typecheck

      - name: Lint
        run: bun run lint

      - name: Run tests
        run: bun run test
        ${config.database === 'postgresql' ? `
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db` : ''}

      ${config.testing.includes('playwright') ? `
      - name: Install Playwright browsers
        run: bunx playwright install --with-deps

      - name: Run E2E tests
        run: bun run test:e2e` : ''}

  build:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build application
        run: bun run build

      ${config.docker && config.deployTarget === 'docker' ? `
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: \${{ secrets.DOCKERHUB_USERNAME }}
          password: \${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: \${{ secrets.DOCKERHUB_USERNAME }}/${config.projectName}:latest,\${{ secrets.DOCKERHUB_USERNAME }}/${config.projectName}:\${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max` : ''}

  deploy:
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      ${config.deployTarget === 'vercel' ? `
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: \${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'` : ''}

      ${config.deployTarget === 'docker' ? `
      - name: Deploy to production
        run: |
          echo "üöÄ Deploy Docker container to production"
          # Add your deployment commands here` : ''}

      ${config.deployTarget === 'netlify' ? `
      - name: Deploy to Netlify
        uses: nwtgck/actions-netlify@v2
        with:
          publish-dir: './dist'
          production-branch: main
          github-token: \${{ secrets.GITHUB_TOKEN }}
          deploy-message: "Deploy from GitHub Actions"
        env:
          NETLIFY_AUTH_TOKEN: \${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: \${{ secrets.NETLIFY_SITE_ID }}` : ''}

      - name: Notify deployment
        run: |
          echo "‚úÖ Deployment completed successfully"
`;

  await fs.writeFile(join(workflowDir, 'ci-cd.yml'), ciWorkflow, 'utf-8');
}

/**
 * Generate Vercel configuration
 */
export async function generateVercelConfig(projectDir: string, config: ProjectConfig): Promise<void> {
  if (config.deployTarget !== 'vercel' && config.cicd !== 'vercel') return;

  const vercelConfig = {
    version: 2,
    name: config.projectName,
    builds: [
      {
        src: 'package.json',
        use: '@vercel/static-build',
        config: {
          distDir: 'dist'
        }
      }
    ],
    routes: [
      {
        src: '/api/(.*)',
        dest: '/api/$1'
      },
      {
        handle: 'filesystem'
      },
      {
        src: '/(.*)',
        dest: '/index.html'
      }
    ],
    env: {
      NODE_ENV: 'production'
    },
    functions: {
      'api/**/*.ts': {
        runtime: 'nodejs18.x'
      }
    },
    ...(config.cicd === 'vercel' && {
      github: {
        silent: true,
        autoAlias: true
      }
    })
  };

  await fs.writeFile(join(projectDir, 'vercel.json'), JSON.stringify(vercelConfig, null, 2), 'utf-8');
}

/**
 * Generate Netlify configuration
 */
export async function generateNetlifyConfig(projectDir: string, config: ProjectConfig): Promise<void> {
  if (config.deployTarget !== 'netlify') return;

  const netlifyToml = `# Netlify configuration
# Generated by create-karetech-stack

[build]
  command = "bun run build"
  publish = "dist"

[build.environment]
  NODE_ENV = "production"
  NODE_VERSION = "18"

[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/:splat"
  status = 200

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    X-XSS-Protection = "1; mode=block"
    Strict-Transport-Security = "max-age=31536000; includeSubDomains"

[[headers]]
  for = "/assets/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[functions]
  directory = "netlify/functions"
  node_bundler = "bun"

${config.auth.length > 0 ? `
[[edge_functions]]
  function = "auth"
  path = "/api/auth/*"
` : ''}

${config.pwa ? `
[[headers]]
  for = "/sw.js"
  [headers.values]
    Cache-Control = "public, max-age=0, must-revalidate"
` : ''}
`;

  await fs.writeFile(join(projectDir, 'netlify.toml'), netlifyToml, 'utf-8');
}

/**
 * Generate environment configuration templates
 */
export async function generateEnvironmentFiles(projectDir: string, config: ProjectConfig): Promise<void> {
  // .env.example template
  const envExample = `# Environment Variables Template
# Copy to .env.local and fill in your values
# Generated by create-karetech-stack

# Application
NODE_ENV=development
PORT=3000
APP_URL=http://localhost:3000

# Database
${config.database === 'postgresql' ? `DATABASE_URL=postgresql://postgres:password@localhost:5432/${config.projectName}` : ''}
${config.database === 'turso' ? `DATABASE_URL=file:./dev.db\nDATABASE_AUTH_TOKEN=` : ''}
${config.database === 'sqlite' ? `DATABASE_URL=file:./dev.db` : ''}

${config.auth.length > 0 ? `
# Authentication
AUTH_SECRET=your-auth-secret-here-minimum-32-characters
AUTH_URL=http://localhost:3000

# OAuth Providers (if using OAuth)
${config.auth.includes('github') ? `GITHUB_CLIENT_ID=\nGITHUB_CLIENT_SECRET=` : ''}
${config.auth.includes('oauth') ? `GOOGLE_CLIENT_ID=\nGOOGLE_CLIENT_SECRET=` : ''}
` : ''}

${config.email !== 'none' ? `
# Email Service
${config.email === 'resend' ? `RESEND_API_KEY=` : ''}
${config.email === 'sendgrid' ? `SENDGRID_API_KEY=` : ''}
${config.email === 'nodemailer' ? `EMAIL_HOST=\nEMAIL_PORT=587\nEMAIL_USER=\nEMAIL_PASS=` : ''}
` : ''}

${config.analytics !== 'none' ? `
# Analytics
${config.analytics === 'google' ? `GA_TRACKING_ID=` : ''}
${config.analytics === 'umami' ? `UMAMI_WEBSITE_ID=\nUMAMI_URL=` : ''}
` : ''}

${config.errorTracking !== 'none' ? `
# Error Tracking
${config.errorTracking === 'sentry' ? `SENTRY_DSN=\nSENTRY_ORG=\nSENTRY_PROJECT=` : ''}
${config.errorTracking === 'bugsnag' ? `BUGSNAG_API_KEY=` : ''}
${config.errorTracking === 'rollbar' ? `ROLLBAR_ACCESS_TOKEN=` : ''}
` : ''}

${config.featureFlags ? `
# Feature Flags
VERCEL_FLAGS_SECRET=
` : ''}

# Development
${config.testing.includes('playwright') ? `PLAYWRIGHT_HEADLESS=true` : ''}
${config.testing.includes('puppeteer') ? `PUPPETEER_HEADLESS=true` : ''}
`;

  await fs.writeFile(join(projectDir, '.env.example'), envExample, 'utf-8');

  // .env.local for development (will be gitignored)
  const envLocal = envExample.replace('# Copy to .env.local and fill in your values', '# Local development environment');
  await fs.writeFile(join(projectDir, '.env.local'), envLocal, 'utf-8');
}

/**
 * Generate deployment scripts
 */
export async function generateDeploymentScripts(projectDir: string, config: ProjectConfig): Promise<void> {
  const scriptsDir = join(projectDir, 'scripts');
  if (!existsSync(scriptsDir)) {
    mkdirSync(scriptsDir, { recursive: true });
  }

  // Health check script
  const healthCheck = `#!/usr/bin/env bun

/**
 * Health check endpoint for load balancers
 * Generated by create-karetech-stack
 */

interface HealthStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  uptime: number;
  version: string;
  database?: boolean;
  redis?: boolean;
}

async function healthCheck(): Promise<HealthStatus> {
  const startTime = Date.now();
  let dbHealthy = true;
  let redisHealthy = true;

  ${config.database !== 'none' ? `
  // Check database connection
  try {
    // Add your database health check here
    // Example: await db.select().from(health).limit(1);
  } catch (error) {
    console.error('Database health check failed:', error);
    dbHealthy = false;
  }
  ` : ''}

  ${config.auth.length > 0 || config.featureFlags ? `
  // Check Redis connection (if using Redis for sessions/cache)
  try {
    // Add your Redis health check here
    // Example: await redis.ping();
  } catch (error) {
    console.error('Redis health check failed:', error);
    redisHealthy = false;
  }
  ` : ''}

  const responseTime = Date.now() - startTime;
  const isHealthy = dbHealthy && redisHealthy && responseTime < 5000;

  return {
    status: isHealthy ? 'healthy' : 'unhealthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version || '1.0.0',
    ${config.database !== 'none' ? 'database: dbHealthy,' : ''}
    ${config.auth.length > 0 || config.featureFlags ? 'redis: redisHealthy,' : ''}
  };
}

// HTTP health endpoint
const server = Bun.serve({
  port: process.env.HEALTH_CHECK_PORT || 8080,
  async fetch(req) {
    if (new URL(req.url).pathname === '/health') {
      const health = await healthCheck();
      return Response.json(health, {
        status: health.status === 'healthy' ? 200 : 503
      });
    }
    return new Response('Not Found', { status: 404 });
  }
});

console.log(\`Health check server running on port \${server.port}\`);
`;

  await fs.writeFile(join(scriptsDir, 'health-check.ts'), healthCheck, 'utf-8');

  // Database initialization script
  if (config.database === 'postgresql') {
    const dbInit = `-- Database initialization script
-- Generated by create-karetech-stack

CREATE DATABASE IF NOT EXISTS ${config.projectName};

-- Create user if not exists (PostgreSQL syntax)
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${config.projectName}_user') THEN
        CREATE ROLE ${config.projectName}_user WITH LOGIN PASSWORD 'development_password';
    END IF;
END
$$;

-- Grant privileges
GRANT ALL PRIVILEGES ON DATABASE ${config.projectName} TO ${config.projectName}_user;

-- Health check table
CREATE TABLE IF NOT EXISTS health (
    id SERIAL PRIMARY KEY,
    status VARCHAR(10) DEFAULT 'ok',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO health (status) VALUES ('ok') ON CONFLICT DO NOTHING;
`;

    await fs.writeFile(join(scriptsDir, 'init-db.sql'), dbInit, 'utf-8');
  }
}

/**
 * Main DevOps generator function
 */
export async function generateDevOpsInfrastructure(projectDir: string, config: ProjectConfig): Promise<void> {
  // Generate Docker configuration
  if (config.docker) {
    await generateDockerfile(projectDir, config);
    await generateDockerCompose(projectDir, config);
  }

  // Generate CI/CD configuration
  if (config.cicd === 'github-actions') {
    await generateGitHubActions(projectDir, config);
  }

  // Generate deployment configurations
  if (config.deployTarget === 'vercel' || config.cicd === 'vercel') {
    await generateVercelConfig(projectDir, config);
  }

  if (config.deployTarget === 'netlify') {
    await generateNetlifyConfig(projectDir, config);
  }

  // Generate environment files
  await generateEnvironmentFiles(projectDir, config);

  // Generate deployment scripts
  await generateDeploymentScripts(projectDir, config);

  console.log('‚úÖ DevOps infrastructure generated');
}

/**
 * Validate DevOps configuration
 */
export function validateDevOpsConfig(config: ProjectConfig): string[] {
  const warnings: string[] = [];

  // Check for suboptimal configurations
  if (config.docker && config.deployTarget === 'vercel') {
    warnings.push('‚ö†Ô∏è  Docker configuration not needed for Vercel deployment');
  }

  if (!config.docker && config.deployTarget === 'docker') {
    warnings.push('‚ö†Ô∏è  Docker deployment target requires Docker configuration');
  }

  if (config.cicd === 'none' && config.deployTarget !== 'manual') {
    warnings.push('‚ö†Ô∏è  Automated deployment requires CI/CD configuration');
  }

  return warnings;
}